## 1. HTTP 리퀘스트 메시지를 작성한다

#### 탐험여행은 URL 입력부터 시작한다

- URL은 http: 뿐만아니라 ftp:, file:, mailto: 로 시작하는것 등 여러가지가 있다.

- 브라우저는 몇개의 클라이언트 기능을 겸비한 복합적인 클라이언트 소프트웨어이며, 어느것을 사용하여 데이터에 액세스하면 좋을것인지 판단하는 재료가 필요하기때문이다.

![](https://velog.velcdn.com/images/dudwls0505/post/81802d23-a0b8-4889-941f-1052cd0e39ee/image.png)

- 액세스 할때의 프로토콜 종류가 쓰여있다.
ex) 액세스 대상이 웹서버라면 HTTP, FTP서버라면 FTP프로토콜을 사용한다. 


#### 브라우저는 먼저 URL을 해독한다

> 브라우저는 웹서버에 보내는 리퀘스트의 메시지를 작성하기위해 가장먼저 URL을 해독한다

예시
`http://www.lab.cyber.co.kr/dir1/file1.html`
- http: http프로토콜에 액세스 한다.
- // : 뒤에 이어지는 문자열이 서버의 이름임을 나타냄
- www.lab.cyber.co.kr : 웹 서버의 이름
- dir1/file1.html : 파일의 경로

#### 파일명을 생략한경우 

`http://www.lab.cyber.co.kr`
`http://www.lab.cyber.co.kr/`

-  대부분의 서버가 index.html 또는 default.html파일명을 설정해두기때문에, 파일명이 생략되어있다면 /index.html 또는 /default.html 파일을 액세스 하게된다. 

`http://www.lab.cyber.co.kr/whatisthis`

- whatisthis라는 디렉토리가 있으면 디렉토리명으로보고, 파일이 있으면 파일명으로 해석한다.

#### HTTP의 기본개념

URL을 해독하고나면 어디에 액세스해야되는지 결정이되며, http라면  브라우저는 HTTP프로토콜을 사용하여 웹서버에 액세스한다.

![](https://velog.velcdn.com/images/dudwls0505/post/f80e8a34-0b06-4871-938c-a6e30faa3940/image.png)

- URI : 액세스 대상(무엇을) 
- 메소드 : 어떻게 , 어떤동작을 하고싶은지 

웹서버에 리퀘스트 메시지가 도착하면 웹서버는 그 내용을 해독한후 결과 데이터를 응답메시지에 저장한다.

- GET : URI로 지정한 정보를도출, 주로 데이터를 조회할때 가장많이 사용된다.
- POST : 클라이언트에서 서버로 데이터를 송신한다. 폼에 입력한 데이터를 송신하는경우에 사용한다. 


#### HTTP 리퀘스트 메시지를 만든다

**request 메시지의 형태**

![](https://velog.velcdn.com/images/dudwls0505/post/6bb6614d-6dc1-4c37-9982-5fd7c53ce588/image.png)

- request Line:`<메소드><공백><URI><공백><HTTP 버전>`  request의 대략적인 내용을 알수있다.

- request Headers: `<필드명>:<필드값>`
request의 부가적인 정보를 나타내며, 공백 행까지 헤더가된다.

- request Message Body: `<메시지본문>`
클라이언트 -> 서버로 송신하는 데이터로 대표적으로 POST메소드를 이용할때 데이터가 들어간다.   
GET메소드 인경우에는 메소드와 URI만으로 웹서버가 무엇을 할지 판단할수있으므로 본문 송신데이터가 비어있다. 


#### 리퀘스트 메시지를 보내면 응답이 되돌아온다

**response 메시지의 형태**

![](https://velog.velcdn.com/images/dudwls0505/post/84439334-9da1-4af3-b2ab-022431ab9e44/image.png)

- Status Line: `<HTTP 버전><공백><응답코드><공백><응답 문구>`
응답코드에는 정상종료,오류,등 request의 실행결과를 나타내는 응답코드와 응답문구를 첫번째 행에 써야한다. 

- Response Message Body : `<메시지본문>` 
서버에서 클라이언트에 송신하는데이터

## 2. 웹서버의 IP주소를 DNS서버에 조회한다

#### IP주소의 기본

> 브라우저는 URL을 해독하거나 HTTP메세지를 만들지만, 메시지를 네트워크에 송출하는 기능은 없으므로 OS에 의뢰하여 송신한다.   
이때 URL안에 쓰여있는 서버의 도메인명에서 IP주소를 조사해야한다.    
OS에 송신을 의뢰할땐 도메인명이 아니라 IP주소로 메시지를 받을 상대를 지정해야되기때문이다.  
**즉, HTTP메시지를 만들고 나서 도메인명에서 IP주소를 조사하는 동작이 이루어진다.**

액세스 대상에 데이터가 도착하는 과정

![](https://velog.velcdn.com/images/dudwls0505/post/bc7fb997-1455-460a-8f93-ea5c9cdd8f61/image.png)

- 서브넷 : 허브에 몇대의 PC가 접속되었다면, 이것을 한개의 단위로 서브넷이라고 한다. 
- 라우터: 패킷을 중계하는 장치의 일종

xx동x번지 라는 형태로 네트워크 주소를 할당하게되는데 동에 해당하는 번호를 서브넷에 할당하고 번지에 해당하는번호를 컴퓨터에 할당한다

송신측이 메시지를 보내면 서브넷안에 있는 허브가 가까운 라우터에 운반하고, 
 라우터가 액세스 대상 주소를 확인하고 그 주소의 방향으로 데이터를 중계한다(다음 라우터로). 서브넷의 허브가 라우터까지 메시지를 보내는 과정을 반복한다.

액세스 대상의 서버까지 메시지를 운반할때, ip주소에 따라 액세스 대상의 위치를 판단하고 운반한다.


- IP주소
`10.11.12.13`
  - 32비트의 디지털 테이터
  - 8비트씩 .으로 구분하여 10진수로 표기
  
- 넷마스크
`255.255.255.0` (10진수 표기)
`11111111.11111111.11111111.00000000`(비트로 표기)
  - IP주소 만으로는 네트워크번호/호스트번호를 구분하기가 힘들기때문에 존재
  - 넷마스크가 1인부분은 네트워크 번호를 나타내고 0인부분은 호스트번호를 나타낸다 


#### 도메인명과 IP주소를 구분하여 사용하는 이유

> TCP/IP의 네트워크는 IP주소로 통신상대를 지정하기때문에 IP주소를 반드시 알아야하며, URL안에 서버명이 아닌 IP주소를 써도 제대로 작동한다. 
**하지만, 기억하기가 어렵기때문에 서버의 이름을 쓸수있도록 하는것이 좋다.**  
  
  
**그럼 아예 IP주소 관두고 이름으로 상대 지정하여 통신하는것이 좋지않을까?**  
=> IP주소는 32비트, 도메인명은 IP주소보다 훨씬큰 바이트를 잡아먹게된다.     
이는 라우터의 부하로 이어져 데이터를 운반하는 동작의 시간이 더 많이 걸릴수있다.  
  
  
#### Socket 라이브러리가 IP주소를 찾는 기능을 제공한다

도메인명으로 IP주소를 조회한다는것은  DNS서버에 요청/응답을 하게된다는 맥락과 비슷하다.  
이 DNS 클라이언트에 해당하는것을 리졸버라고 부른다. 
리졸버가 DNS의 원리로 IP주소를 조사하는것이며, Socket라이브러리 속에 있는 부품중 하나다.    
  
#### 리졸버 내부작동

네트워크 애플리케이션이 리졸버 호출 -> 제어권이 리졸버의 내부로 넘어감 ->     

Socket라이브러리의 내용들이 실행되고  요청받은 작업들 실행 ->   

DNS서버에 문의하기위한 메시지 생성 (이 과정에서 OS내부에 프로토콜 스택을 호출하여 실행)  

-> LAN어댑터를 통해 메시지가 DNS서버를 향해 송신-> DNS서버에서 답을 찾아 응답 ->   

반환된 메시지를 프로토콜 스택을 경유하여 리졸버에 건네지고, 리졸버가 내용을 해독한후 IP주소를 추출하여 애플리케이션에 IP주소를 건네준다

-> 애플리케이션으로 제어가 돌아온다.


## 3. 전 세계의 DNS서버가 연대한다

#### DNS 서버의 기본동작
`www.naver.com` 이라는 이름을가진 서버의 IP주소를 조사하려고 할때, 클라이언트는 다음과 같은 정보를 포함한 조회메시지를 DNS서버에 보낸다.
> 이름 = www.naver.com
클래스 = IN(인터넷 네트워크를 의미)
타입 = A(IP 주소가아닌 다른 타입이라면 변경될수있다)

다음과같은 형식과 일치하는 것을 찾아 반환한다. 


#### 도메인의 계층

> 앞에서 살펴봤던 DNS서버에서 형식과 일치하는 IP주소를 찾는과정은  
> 한대의 DNS서버에 인터넷에 존재하는 막대한 수의 서버를 저장할수없다.  
**사실, 정보를 분산시켜 다수의 DNS서버에 등록하고 다수의 DNS서버가 연대하여 어디에 정보가 등록되어있는지 찾아내는 과정이다.**  

DNS서버에 등록된 정보는 계층구조를 가지게되며 `.`이 구분자가 된다.
`www.naver.com`이 존재한다면, com이라는 도메인아래에 naver라는 도메인이있고 그 안에 www라는 이름이 있게된다.


#### 담당 DNS 서버를 찾아 IP 주소를 가져온다

- 수많은 DNS서버가 존재하기때문에 일일히 뒤질수 없음
- `www.naver.com`이라는 도메인을 담당하는 DNS서버를  `naver.com`의 DNS서버에 등록하며, `com` DNS서버에 최종 등록하는방식

![](https://velog.velcdn.com/images/dudwls0505/post/fbe4328b-82b8-42e9-bc0f-10fdef7b0a90/image.png)


- 최상단에 루트 도메인이라는것도 존재하며, 루트 도메인의 DNS서버를 인터넷에 존재하는 DNS서버에 전부 등록하여 모든 DNS서버가 루트도메인에 액세스할수있게 된다. 

- 캐시 기능도 존재한다

흐름
요청받은 웹서버에 대한 정보(www.naver.com)를 조회 -> 가장가까운 DNS서버에 등록되어있지않음 ->  

루트도메인의 DNS서버가 가장 가까운 DNS서버에는 등록되어있으므로 루트도메인으로 찾고자하는 웹서버 정보를 전송 ->   

루트도메인에 존재하지않지만, com아래에있으므로 타고내려갔으나 없기때문에 다시DNS서버에 전달 -> naver.com도메인의 dns서버 ip주소를 반송  


## 4. 프로토콜 스택에 메시지 송신을 의뢰한다

#### 데이터 송수신 동작의 개요

IP주소를 찾고, 액세스 대상 웹서버에 메시지를 송신하도록 OS내부의 프로토콜 스택에 의뢰해야한다.
이 과정은 Socket라이브러리 프로그램의 결정된 순번대로 호출된다

![](https://velog.velcdn.com/images/dudwls0505/post/5cee310b-aaa5-46b7-ac70-df47a440ca3f/image.png)

데이터를 송수신하는 통로가 있는데, 이통로를 만들기전에 양끝에있는 소켓을 만들고 연결해야한다 
- 서버측에서 소켓을 생성
- 소켓에 클라이언트가 서버측 소켓에 파이프를 연결
- 데이터 송.수신
- 데이터를 전부보내고 파이프 분리 


#### 소켓의 작성 단계

소켓 라이브러리의 프로그램부품만 호출하면 소켓이 만들어진다.소켓이 생기면 디스크립터라는 번호표같은것으로 소켓을 식별한다(2개의 브라우저 창을 열경우 2개의 다른 웹서버에 접속할경우)


#### 파이프를 연결하는 접속 단계

- 디스크립터(컴퓨터 한대 내부에서 소켓을 식별하기위해 사용)
- 서버의IP주소
- 포트번호 => 접속 상대의 소켓을 지정할수있다.(접속 상대측에서 소켓을 식별하기위해 사용하며, 미리 결정된 포트번호를 사용한다)

3가지값을 지정하여 connect를 호출하여 의뢰 동작을 실행한다

#### 메시지를 주고받는 송수신 단계

소켓이 상대측과 연결되면 자유롭게 데이터를 전송할수있다.

![](https://velog.velcdn.com/images/dudwls0505/post/1cdcf3de-9489-49aa-889d-05696066fa8a/image.png)

-  애플리케이션은 송신데이터(입력한 URL바탕으로 생성한 HTTP 요청메시지)를 메모리에 준비한다
- write를 호출하여 디스크립터, 송신데이터를 지정한다
- 프로토콜 스택이 송신 데이터를 서버에 송신한다 
- 소켓에는 연결된 상대를 알고있으므로, 전달받은 디스크립터로 대상을 판별해 메시지를 전달한다. 
